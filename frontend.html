<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CTF Terminal</title>
  <style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background: #1e1e1e;
    font-family: 'Courier New', monospace;
    color: #d4d4d4;
    height: 100vh;
    overflow: hidden;
  }

  .terminal-container {
    max-width: 1100px;
    margin: 0 auto;
    height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 12px;
  }

  /* HEADER */
  .terminal-header {
    background: #2d2d2d;
    padding: 8px 14px;
    border-bottom: 1px solid #333;
    display: flex;
    align-items: center;
    gap: 8px;
    border-radius: 6px 6px 0 0;
  }

  .terminal-button {
    width: 11px;
    height: 11px;
    border-radius: 50%;
  }

  .btn-red { background: #ff5f56; }
  .btn-yellow { background: #ffbd2e; }
  .btn-green { background: #27c93f; }

  .terminal-title {
    margin-left: 12px;
    color: #9cdcfe;
    font-size: 13px;
    letter-spacing: 0.5px;
  }

  /* BODY */
  .terminal-body {
    background: #1e1e1e;
    flex: 1;
    padding: 16px;
    overflow-y: auto;
    border: 1px solid #333;
    border-top: none;
    border-radius: 0 0 6px 6px;
  }

  .terminal-output {
    margin-bottom: 18px;
  }

  .output-line {
    margin: 6px 0;
    line-height: 1.5;
    white-space: pre-wrap;
  }

  /* TEXT COLORS */
  .prompt {
    color: #4fc1ff;
    font-weight: bold;
  }

  .command {
    color: #9cdcfe;
  }

  .success {
    color: #6a9955;
  }

  .error {
    color: #f44747;
  }

  .info {
    color: #dcdcaa;
  }

  .question {
    color: #c586c0;
    margin: 12px 0;
    font-weight: normal;
  }

  .story {
    color: #b5cea8;
    font-style: italic;
    margin: 10px 0;
  }

  .link {
    color: #4ec9b0;
    text-decoration: none;
  }

  .link:hover {
    text-decoration: underline;
  }

  /* INPUT */
  .input-line {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .hidden-flag {
    display: none;
  }

  #terminal-input {
    flex: 1;
    background: transparent;
    border: none;
    color: #d4d4d4;
    font-family: 'Courier New', monospace;
    font-size: 15px;
    outline: none;
    caret-color: #dcdcaa;
  }

  /* ASCII */
  .ascii-art {
    color: #4fc1ff;
    font-size: 12px;
    line-height: 1.3;
    white-space: pre;
  }

  /* TABLE (LEADERBOARD) */
  .table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 12px;
    font-size: 14px;
  }

  .table th {
    color: #4fc1ff;
    text-align: left;
    padding: 6px 8px;
    border-bottom: 1px solid #333;
  }

  .table td {
    padding: 6px 8px;
    border-bottom: 1px solid #2a2a2a;
  }

  .table tr:hover {
    background: #252526;
  }

  /* SCROLLBAR */
  ::-webkit-scrollbar {
    width: 6px;
  }

  ::-webkit-scrollbar-track {
    background: #1e1e1e;
  }

  ::-webkit-scrollbar-thumb {
    background: #3c3c3c;
    border-radius: 3px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
  
</style>

</head>
<body>
  <div class="terminal-container">
    <div class="terminal-header">
      <div class="terminal-button btn-red"></div>
      <div class="terminal-button btn-yellow"></div>
      <div class="terminal-button btn-green"></div>
      <span class="terminal-title">CTF Terminal</span>
    </div>
    <div class="terminal-body" id="terminal-body">
      <div class="terminal-output" id="output"></div>
      <div class="input-line">
        <span class="input-prompt" id="prompt-text">root@ctf:~$</span>
        <span class="hidden-flag">FLAG{h1dd3n_1n_html}</span>
        <input type="text" id="terminal-input" autofocus />
      </div>
    </div>
  </div>

  <script>
    const API_BASE = 'https://ctf-backend-ten.vercel.app/api';
    const output = document.getElementById('output');
    const input = document.getElementById('terminal-input');
    const promptText = document.getElementById('prompt-text');
    
    let token = null;
    let isLoggedIn = false;
    let currentUser = null;
    let awaitingInput = false;
    let inputCallback = null;
    let commandHistory = [];
    let historyIndex = -1;

    const commands = {
      help: 'Show available commands and their descriptions',
      login: 'Login to start the CTF challenge',
      start: 'Get the current question (requires login)',
      submit: 'Submit a flag (requires login)',
      leaderboard: 'Display the CTF leaderboard',
      whoami: 'Display current user information',
      clear: 'Clear the terminal screen',
      banner: 'Display the CTF banner',
      exit: 'Logout from the current session'
    };

    const banner = `
<span style="color: #1e1e1e;">FLAG{c0l0r_bl3nd_m4st3r}</span>
    `;

    function addOutput(text, className = '') {
      const line = document.createElement('div');
      line.className = `output-line ${className}`;
      line.innerHTML = text;
      output.appendChild(line);
      scrollToBottom();
    }

    function scrollToBottom() {
      const body = document.getElementById('terminal-body');
      body.scrollTop = body.scrollHeight;
    }

    function updatePrompt(text) {
      promptText.textContent = text;
    }

    function waitForInput(callback, prompt) {
      awaitingInput = true;
      inputCallback = callback;
      updatePrompt(prompt);
    }

    function showBanner() {
      addOutput(`<pre class="ascii-art">${banner}</pre>`);
      addOutput('Welcome to CTF Terminal!', 'info');
      addOutput('Type <span class="command">\'login\'</span> to begin\n', 'info');
    }

    function showHelp() {
      addOutput('\n<span class="info">Available Commands:</span>');
      addOutput('‚îÄ'.repeat(60));
      for (const [cmd, desc] of Object.entries(commands)) {
        addOutput(`  <span class="command">${cmd.padEnd(15)}</span> - ${desc}`);
      }
      addOutput('‚îÄ'.repeat(60) + '\n');
    }

    async function handleLogin() {
      // Get email
      const email = await new Promise(resolve => {
        waitForInput(resolve, 'Email:');
      });

      // Get password
      const password = await new Promise(resolve => {
        input.type = 'password';
        waitForInput(resolve, 'Password:');
      });

      input.type = 'text';
      updatePrompt('root@ctf:~$');
      
      addOutput('Press Enter to submit', 'info');
      addOutput('Validating credentials...\n', 'info');

      try {
        const res = await fetch(`${API_BASE}/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ emailID: email, password })
        });

        const data = await res.json();

        if (data.success) {
          token = data.token;
          isLoggedIn = true;
          currentUser = data.user;
          addOutput(`<span class="success">‚úì AUTHENTICATED</span>`, 'success');
          addOutput(`Type <span class="command">"start"</span> to begin the CTF challenge`, 'info');
          addOutput(`Type <span class="command">"leaderboard"</span> to view rankings\n`, 'info');
        addOutput(`Type <span class="command">"leaderboard"</span> to view rankings\n`, 'info');

        } else {
          addOutput(`<span class="error">‚úó ${data.message}</span>\n`, 'error');
        }
      } catch (err) {
        addOutput(`<span class="error">‚úó Login failed: ${err.message}</span>\n`, 'error');
      }
    }

    async function startChallenge() {
      if (!isLoggedIn) {
        addOutput('<span class="error">‚úó Please login first using the <span class="command">login</span> command.</span>\n', 'error');
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/ctf/question`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const data = await res.json();

        if (data.success) {
          if (data.completed) {
            addOutput(`\n<span class="success">üéâ ${data.message}</span>`, 'success');
            addOutput(`Total Levels: ${data.totalLevels}`, 'info');
            addOutput(`Time: ${formatTime(data.startTime, data.endTime)}\n`, 'info');
          } else {
            addOutput('Starting CTF challenge...\n', 'info');
            addOutput(`<span class="info">[Question ${data.level}]</span>`, 'info');
            
            if (data.story) {
              addOutput(`<div class="story">${data.story}</div>`);
            }

            if (data.question) {
              addOutput(`<div class="question">${data.question}</div>`);
            }

            if (data.link) {
              addOutput(`<div>üìé Download: <a href="${data.link}" target="_blank" class="link">${data.link}</a></div>`);
            }

            if (data.isFinalStory) {
              addOutput(`\n<span class="success">üéä Congratulations! You've completed all challenges!</span>`, 'success');
              addOutput(`Time taken: ${formatTime(data.startTime, data.endTime)}\n`, 'info');
            } else {
              addOutput('');
            }
          }
        } else {
          addOutput(`<span class="error">‚úó ${data.message}</span>\n`, 'error');
        }
      } catch (err) {
        addOutput(`<span class="error">‚úó Failed to fetch question: ${err.message}</span>\n`, 'error');
      }
    }

    async function submitCommand() {
      if (!isLoggedIn) {
        addOutput('<span class="error">‚úó Please login first.</span>\n', 'error');
        return;
      }

      const flag = await new Promise(resolve => {
        waitForInput(resolve, 'Submit flag:');
      });

      updatePrompt('root@ctf:~$');

      if (!flag || !flag.trim()) {
        addOutput('<span class="error">‚úó Flag cannot be empty</span>\n', 'error');
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/ctf/check-flag`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ flag: flag.trim() })
        });

        const data = await res.json();

        if (data.success) {
          addOutput(`<span class="success">‚úì ${data.message}</span>\n`, 'success');
          
          if (!data.completed && !data.isLastFlag) {
            setTimeout(() => startChallenge(), 500);
          } else if (data.isLastFlag) {
            addOutput('Type <span class="command">start</span> to see the final story!\n', 'info');
          }
        } else {
          addOutput(`<span class="error">‚úó ${data.message}</span>\n`, 'error');
        }
      } catch (err) {
        addOutput(`<span class="error">‚úó Failed to submit flag: ${err.message}</span>\n`, 'error');
      }
    }

    async function showLeaderboard() {
      try {
        const res = await fetch(`${API_BASE}/ctf/leaderboard`);
        const data = await res.json();

        if (data.success) {
          addOutput('\n<span class="info">‚ïê‚ïê‚ïê CTF Leaderboard ‚ïê‚ïê‚ïê</span>', 'info');
          
          if (data.data.length === 0) {
            addOutput('No participants yet.\n', 'info');
            return;
          }

          const table = document.createElement('table');
          table.className = 'table';
          
          const thead = `
            <thead>
              <tr>
                <th>Rank</th>
                <th>Name</th>
                <th>Branch</th>
                <th>Year</th>
                <th>Questions Solved</th>
                <th>Time Taken</th>
              </tr>
            </thead>
          `;

          let tbody = '<tbody>';
          data.data.forEach(user => {
            const time = user.timeTakenFormatted 
              ? `${String(user.timeTakenFormatted.hours).padStart(2, '0')}:${String(user.timeTakenFormatted.minutes).padStart(2, '0')}:${String(user.timeTakenFormatted.seconds).padStart(2, '0')}`
              : 'N/A';
            
            tbody += `
              <tr>
                <td>${user.rank}</td>
                <td>${user.name}</td>
                <td>${user.department}</td>
                <td>${user.year}</td>
                <td>${user.numberOfLevelsCompleted}</td>
                <td>${time}</td>
              </tr>
            `;
          });
          tbody += '</tbody>';

          table.innerHTML = thead + tbody;
          
          const wrapper = document.createElement('div');
          wrapper.appendChild(table);
          output.appendChild(wrapper);
          addOutput('');
          scrollToBottom();
        } else {
          addOutput(`<span class="error">‚úó ${data.message}</span>\n`, 'error');
        }
      } catch (err) {
        addOutput(`<span class="error">‚úó Failed to fetch leaderboard: ${err.message}</span>\n`, 'error');
      }
    }

    function whoami() {
      if (!isLoggedIn) {
        addOutput('<span class="error">‚úó Not logged in. Use <span class="command">login</span> command.</span>\n', 'error');
        return;
      }

      addOutput('\n<span class="info">Current User:</span>', 'info');
      addOutput(`  Name:   ${currentUser.name}`, 'info');
      addOutput(`  Email:  ${currentUser.emailID}`, 'info');
      addOutput(`  Branch: ${currentUser.branch}`, 'info');
      addOutput(`  Year:   ${currentUser.year}\n`, 'info');
    }

    function formatTime(start, end) {
      if (!start || !end) return 'N/A';
      const diff = new Date(end) - new Date(start);
      const hours = Math.floor(diff / 3600000);
      const minutes = Math.floor((diff % 3600000) / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    async function handleCommand(cmd) {
      const [command, ...args] = cmd.trim().split(' ');
      
      addOutput(`<span class="prompt">root@ctf:~$</span> <span class="command">${cmd}</span>`);

      // Add to command history
      if (cmd.trim() && (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== cmd)) {
        commandHistory.push(cmd);
      }
      historyIndex = commandHistory.length;

      switch (command.toLowerCase()) {
        case 'help':
          showHelp();
          break;
        case 'login':
          await handleLogin();
          break;
        case 'start':
          await startChallenge();
          break;
        case 'submit':
          await submitCommand();
          break;
        case 'leaderboard':
          await showLeaderboard();
          break;
        case 'whoami':
          whoami();
          break;
        case 'clear':
          output.innerHTML = '';
          break;
        case 'banner':
          showBanner();
          break;
        case 'exit':
          if (isLoggedIn) {
            token = null;
            isLoggedIn = false;
            currentUser = null;
            addOutput('<span class="success">‚úì Logged out successfully.</span>\n', 'success');
          } else {
            addOutput('<span class="error">‚úó Not logged in.</span>\n', 'error');
          }
          break;
        case '':
          break;
        default:
          addOutput(`<span class="error">Command not found: ${command}</span>`, 'error');
          addOutput('Type <span class="command">help</span> for available commands.\n', 'info');
      }
    }

    input.addEventListener('keydown', async (e) => {
      // Handle up/down arrow for command history
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (commandHistory.length > 0 && historyIndex > 0) {
          historyIndex--;
          input.value = commandHistory[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.value = commandHistory[historyIndex];
        } else {
          historyIndex = commandHistory.length;
          input.value = '';
        }
      } else if (e.key === 'Enter') {
        const cmd = input.value;
        input.value = '';
        
        if (awaitingInput && inputCallback) {
          awaitingInput = false;
          const callback = inputCallback;
          inputCallback = null;
          callback(cmd);
        } else {
          await handleCommand(cmd);
        }
      }
    });

    // Initialize
    showBanner();
  </script>
</body>
</html>